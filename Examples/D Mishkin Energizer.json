{
    "problem": {
        "title": "D. Mishkin Energizer",
        "description": "In anticipation of a duel with his old friend Fernan, Edmond is preparing an energy drink called \"Mishkin Energizer\". The drink consists of a string ss of length nn, made up only of the characters L, I, and T, which correspond to the content of three different substances in the drink.We call the drink balanced if it contains an equal number of all substances. To boost his aura and ensure victory in the duel, Edmond must make the initial string balanced by applying the following operation: Choose an index ii such that si≠si+1si≠si+1 (where i+1i+1 must not exceed the current size of the string). Insert a character xx, either L, I, or T, between them such that x≠six≠si and x≠si+1x≠si+1. Help Edmond make the drink balanced and win the duel by performing no more than 2n2n operations. If there are multiple solutions, any one of them can be output. If it is impossible, you must report this.",
        "input": "InputEach test consists of several test cases. The first line of the input data contains one integer tt (1≤t≤1001≤t≤100) — the number of test cases. The description of the test cases follows.The first line of each test case contains one integer nn (1≤n≤1001≤n≤100) — the length of the string ss.The second line of each test case contains a string ss of length nn, consisting only of the characters L, I, and T.",
        "output": "OutputFor each test case, output −1−1 if there is no solution. Otherwise, in the first line, output a single integer mm (0≤m≤2n0≤m≤2n) — the number of operations you performed.Then the ll-th of the following mm lines should contain a single integer ii (1≤i<n+l−11≤i<n+l−1), indicating the operation of inserting a character between sisi and si+1si+1. It must hold that si≠si+1si≠si+1.If there are multiple solutions, any one of them can be output. Note that you do not need to minimize the number of operations in this problem.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "greedy",
            "implementation",
            "strings",
            "*1800"
        ],
        "examples": [
            {
                "input": "35TILII1L3LIT",
                "output": "4 1 2 3 4 -1 0"
            }
        ]
    },
    "solution": {
        "description": "It is clear that there is no solution if all the letters in s are the same. Let us now prove that a solution always exists in all other cases.While the string remains unbalanced, let us assume that cnt(a)≤cnt(b)≤cnt(c), where a,b,c∈{L,I,T}, and cnt(l) denotes the number of occurrences of the letter l in s. Consider two cases: The string s contains the substring bc or cb. In this case, we can perform the operation on it to obtain bac or cab. Otherwise, the string s must contain the substring ca or ac. Without loss of generality, assume that s contains ca. Then we can perform the following sequence of operations: ca -> cba -> cbca -> cbaca -> cabaca. It can be observed that after each operation, the value of 2⋅cnt(c)−cnt(b)−cnt(a) decreases by one. Here, a, b, and c are always chosen such that cnt(a)≤cnt(b)≤cnt(c). Therefore, the algorithm is guaranteed to terminate, and it does so when 2⋅cnt(c)−cnt(b)−cnt(a)=0, which implies cnt(a)=cnt(b)=cnt(c).It remains to prove that the number of operations performed by the proposed algorithm does not exceed 2n. ProofAssume that initially x=cnt(a),y=cnt(b),z=cnt(c), where cnt(a)≤cnt(b)≤cnt(c). Then x+y+z=n.While cnt(a)<cnt(b), we increment cnt(a) by one in each step, using no more than 4 operations per step. Therefore, this phase requires at most 4(y−x) operations. Afterwards, the algorithm alternately increments cnt(a) and cnt(b) by one until both become equal to cnt(c). I claim that this phase will use the 4-operations sequence (i.e., the second case in the algorithm) at most once. Indeed, let us consider the first time we perform the transformation ca -> cabaca. It is easy to see that all subsequent steps will involve only single-operation transformations. Thus, this phase requires no more than 2(z−y)+3 operations. Summing up, the total number of operations is bounded above by 4(y−x)+2(z−y)+3=2z+2y−4x+3. If x≠0, this number is less than 2n given that n=x+y+z. Otherwise, the first step of the algorithm will be either bc -> bac or cb -> cab, requiring only one operation. This improves the estimate for the number of operations in the first phase from 4(y−x) to 4(y−x)−3. As a result, in the case where x=0, the total number of operations does not exceed 4(y−x)−3+2(z−y)+3=2z+2y=2n.",
        "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n \nusing namespace std;\n \nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    string base = \"LIT\";\n    int t; cin >> t;\n    while (t--) {\n        int n; string s;\n        cin >> n >> s;\n        if (count(s.begin(), s.end(), s[0]) == n) {\n            cout << -1 << '\\n';\n        } else {\n            vector <int> ans;\n            while (true) {\n                vector <pair<int, char>> cnt;\n                for (auto i : base) cnt.push_back(make_pair(count(s.begin(), s.end(), i), i));\n                sort(cnt.begin(), cnt.end());\n                if (cnt[0].first == cnt[1].first && cnt[1].first == cnt[2].first) break;\n \n                auto op = [&] (int i) -> void {\n                    string z = base; z.erase(find(z.begin(), z.end(), s[i])); z.erase(find(z.begin(), z.end(), s[i + 1]));\n                    ans.push_back(i);\n                    s = s.substr(0, i + 1) + z[0] + s.substr(i + 1);\n                };\n \n                bool done = false;\n                for (int i = 0; i < s.size() - 1; ++i) {\n                    if (s[i] == s[i + 1]) continue;\n                    if (s[i] != cnt[0].second && s[i + 1] != cnt[0].second) {\n                        op(i); \n                        done = true;\n                        break;\n                    }\n                }\n                \n                if (done) continue;\n                \n                for (int i = 0; i < s.size() - 1; ++i) {\n                    if (s[i] == s[i + 1]) continue;\n                    if (s[i] == cnt[2].second) {\n                        op(i); op(i + 1); op(i); op(i + 2); break;\n                    } else if (s[i + 1] == cnt[2].second) {\n                        op(i); op(i); op(i + 1); op(i + 3); break;\n                    }\n                }\n            }\n            \n            cout << ans.size() << '\\n';\n            for (auto i : ans) cout << i + 1 << '\\n';\n        }\n    }\n}\n"
    }
}