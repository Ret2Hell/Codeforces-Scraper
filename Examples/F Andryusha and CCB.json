{
    "problem": {
        "title": "F. Andryusha and CCB",
        "description": "Let us define the beauty of a binary string zz as the number of indices ii such that 1≤i<|z|1≤i<|z| and zi≠zi+1zi≠zi+1.While waiting for his friends from the CCB, Andryusha baked a pie, represented by a binary string ss of length nn. To avoid offending anyone, he wants to divide this string into kk substrings such that each digit belongs to exactly one substring, and the beauties of all substrings are the same.Andryusha does not know the exact number of friends from the CCB who will come to his house, so he wants to find the number of values of kk for which it is possible to split the pie into exactly kk parts with equal beauties.However, Andryusha's brother, Tristan, decided that this formulation of the problem is too simple. Therefore, he wants you to find the number of such values of kk for each prefix of the string. In other words, for each ii from 11 to nn, you need to find the number of values of kk for which it is possible to split the prefix s1s2…sis1s2…si into exactly kk parts with equal beauties.",
        "input": "InputEach test consists of several test cases. The first line of the input data contains one integer tt (1≤t≤1051≤t≤105) — the number of test cases. The description of the test cases follows.The first line of each test case contains a single integer nn (1≤n≤1061≤n≤106) — the length of the binary string.The second line of each test case contains a binary string of length nn, consisting only of digits 0 and 1.It is guaranteed that the sum of nn across all test cases does not exceed 106106.",
        "output": "OutputFor each test case, output a single line containing nn integers cici (0≤ci≤n0≤ci≤n) — the number of values of kk for which it is possible to split the prefix s1s2…sis1s2…si into exactly kk parts with equal beauties.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "greedy",
            "math",
            "number theory",
            "strings",
            "*2900"
        ],
        "examples": [
            {
                "input": "350001110010101010170010100",
                "output": "1 2 3 4 5 1 2 2 3 2 4 2 4 3 4 1 2 3 3 4 3 4"
            }
        ]
    },
    "solution": {
        "description": "First, note that it is sufficient to consider only two types of blocks of consecutive 0s and 1s: those of size 11 and those of size greater than 11. Based on this, we construct a new string of length szsz, consisting of characters 1 and 2, representing the types of blocks. For example, for the original string 00101110, the new string is 21121.Let’s fix a value of mm—the desired beauty of the substrings we are dividing the string into. It is easy to see that there are O(szm)O(szm) possible values of kk (the number of substrings).Now, for a fixed pair (m,k)(m,k), let SkSk be the set of indices ii such that it is possible to divide the prefix [1,i][1,i] of the new string (representing block types) into kk substrings of beauty mm. It is claimed that SkSk forms a continuous segment [l,r][l,r] for some 1≤l≤r≤sz1≤l≤r≤sz. Let’s prove this by induction.Base case (k=1k=1). We set l=ml=m, r=mr=m (0-based indexing).Inductive step (k->k+1k->k+1). Suppose that for every index i∈[l,r]i∈[l,r], the first ii blocks can be divided into kk substrings of beauty mm. Then we can construct a valid division into k+1k+1 substrings by: Simply appending a new substring of length m+1m+1 starting at block i+1i+1, giving us a new upper bound at i+m+1i+m+1. Additionally, if block ii is of type 22, we can split it between the kk-th and (k+1)(k+1)-th substrings, allowing us to finish the kk-th substring earlier and start the (k+1)(k+1)-th within the same block. This enables us to reach i+mi+m as well. Thus, we conclude: Sk+1=[l+m,r+m+1]Sk+1=[l+m,r+m+1] if the ll-th block is of type 2. Otherwise, Sk+1=[l+m+1,r+m+1]Sk+1=[l+m+1,r+m+1]. To compute the full solution, we iterate over all values of mm from 11 to sz−1sz−1. For each mm, we iterate over kk until the left bound ll of the corresponding segment exceeds szsz. The special case m=0m=0 should be handled separately.For each kk, we need to increment the answer for all positions from ll to rr by one. This can be efficiently done by recording the operations (l,+1)(l,+1) and (r+1,−1)(r+1,−1) and then applying a scanline technique to process the accumulated changes.Since there are O(szm)O(szm) possible values of kk for each mm, the total complexity of this solution is O(nlogn)O(nlog⁡n).",
        "code": "#include <iostream>\n#include <vector>\n \nusing namespace std;\n \nusing ll = long long;\n \nvoid solve() {\n    int n; cin >> n;\n    string s; cin >> s;\n    vector <int> a;\n    int curr = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i && s[i] != s[i - 1]) {\n            if (curr) a.push_back(curr);\n            curr = 1;\n        }\n        else ++curr;\n    }\n    a.push_back(curr);\n    int sz = a.size();\n \n    vector <int> ans(n, 0), left(sz, 0), right(sz, 0);\n    for (int i = 0; i < sz; ++i) {\n        if (!i) {\n            left[i] = 0; right[i] = a[i] - 1;\n        } else {\n            left[i] = right[i - 1] + 1;\n            right[i] = left[i] + a[i] - 1;\n        }\n    }\n    for (int i = 0; i < sz; ++i) {\n        for (int j = left[i]; j <= right[i]; ++j) {\n            ans[j] += j - i + 1;\n        }\n    }\n    vector <int> add(sz, 0);\n    for (int m = 1; m < sz; ++m) {\n        ll l = m, r = m, k = 1;\n        while (l < sz) {\n            ++add[l];\n            if (r + 1 < sz) --add[r + 1];\n \n            if (a[l] == 1) {\n                l += m + 1;\n            } else {\n                l += m;\n            }\n \n            r += m + 1;\n            ++k;\n        }\n    }\n    int pref = 0;\n    for (int i = 0; i < sz; ++i) {\n        pref += add[i];\n        for (int j = left[i]; j <= right[i]; ++j) {\n            ans[j] += pref;\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        cout << ans[i];\n        if (i != n - 1) cout << ' ';\n    }\n    cout << '\\n';\n}\n \nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int t; cin >> t;\n    while (t--) {\n        solve();\n    }\n}\n\n"
    }
}